/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, {
  forwardRef,
  useImperativeHandle,
  useState,
  useRef,
} from "react";
import {
  useGLTF,
  Text,
  useTexture,
  MeshDistortMaterial,
} from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import type { GLTF } from "three-stdlib";
import { RigidBody, type RapierRigidBody } from "@react-three/rapier";
import { useGame } from "../../game";
import { useGameUI } from "../../stores/useGameUI";
import { useDoorSequence } from "../../stores/useDoorSequence";
import { useCanvasManager } from "../../stores/useCanvasManager";
import { getDoorByNumber } from "../../game/doorPrompts";
import { useOrbStore } from "../../stores/useOrbStore";

export interface OniricHallwayRef {
  openDoor: () => void;
  closeDoor: () => void;
  toggleDoor: () => void;
  isOpen: boolean;
}

type GLTFResult = GLTF & {
  nodes: {
    // Puerta (reutilizada para todas las instancias)
    Mesh004: THREE.Mesh;
    Mesh004_1: THREE.Mesh;
    frame: THREE.Mesh;
    // Estructura est치tica
    Plane: THREE.Mesh;
    Paredes: THREE.Mesh;
    Collider: THREE.Mesh;
  };
  materials: {
    ["door wood"]: THREE.MeshPhysicalMaterial;
    ["vray hr134.001"]: THREE.MeshPhysicalMaterial;
    ["Red Carpet"]: THREE.MeshStandardMaterial;
    ["Wooden wall"]: THREE.MeshStandardMaterial;
    ["Material.032"]: THREE.MeshStandardMaterial;
  };
};

// Componente Door reutilizable - cada instancia tiene su propio estado
interface DoorProps {
  doorNumber: number; // 1-9
  position: [number, number, number];
  rotation?: [number, number, number];
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}

function Door({
  doorNumber,
  position,
  rotation = [0, 0, 0],
  nodes,
  materials,
}: DoorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const doorMeshRef = useRef<THREE.Group>(null);
  const doorRbRef = useRef<RapierRigidBody>(null);
  const { onDoorOpen, canInteract } = useGame();
  const showMessage = useGameUI((state) => state.showMessage);

  // Sistema de secuencia de puertas
  const isDoorUnlocked = useDoorSequence((state) => state.isDoorUnlocked);
  const isDoorCurrentlyOpen = useDoorSequence(
    (state) => state.isDoorCurrentlyOpen
  );
  const openDoorInSequence = useDoorSequence((state) => state.openDoor);
  const getNextDoor = useDoorSequence((state) => state.getNextDoor);

  // Orb store para verificar estado de absorci칩n
  const absorptionState = useOrbStore((state) => state.absorptionState);

  // Canvas manager para eventos de cambio de canvas
  const onNinthDoorOpened = useCanvasManager(
    (state) => state.onNinthDoorOpened
  );

  // Refs para acceso estable en callbacks
  const isOpenRef = useRef(isOpen);
  const canInteractRef = useRef(canInteract);
  const doorNumberRef = useRef(doorNumber);
  isOpenRef.current = isOpen;
  canInteractRef.current = canInteract;
  doorNumberRef.current = doorNumber;

  // 츼ngulo actual de la puerta (para animaci칩n suave)
  const currentAngle = useRef(0);
  const targetAngle = useRef(0);

  // Vectores temporales para sincronizar collider
  const tempPosition = useRef(new THREE.Vector3());
  const tempQuaternion = useRef(new THREE.Quaternion());

  // Sincronizar estado visual con el store (para cierre autom치tico)
  React.useEffect(() => {
    const currentlyOpen = isDoorCurrentlyOpen(doorNumber);
    if (isOpen !== currentlyOpen) {
      setIsOpen(currentlyOpen);
    }
  }, [isDoorCurrentlyOpen, doorNumber, isOpen]);

  // Animaci칩n y sincronizaci칩n del collider
  useFrame((_, delta) => {
    const openAngle = -Math.PI / 1.1;
    targetAngle.current = isOpen ? openAngle : 0;
    currentAngle.current = THREE.MathUtils.lerp(
      currentAngle.current,
      targetAngle.current,
      delta
    );

    if (doorMeshRef.current) {
      doorMeshRef.current.rotation.y = currentAngle.current;

      if (doorRbRef.current) {
        doorMeshRef.current.getWorldPosition(tempPosition.current);
        doorMeshRef.current.getWorldQuaternion(tempQuaternion.current);
        doorRbRef.current.setNextKinematicTranslation(tempPosition.current);
        doorRbRef.current.setNextKinematicRotation(tempQuaternion.current);
      }
    }
  });

  const toggleDoor = () => {
    // Primero verificar si el stream est치 conectado
    if (!canInteract) {
      showMessage("The door is locked", "warning");
      return;
    }

    const currentlyOpen = isDoorCurrentlyOpen(doorNumber);

    // Si la puerta ya est치 abierta, no hacer nada (cierre es autom치tico)
    if (currentlyOpen) {
      return;
    }

    // Si hay absorci칩n en progreso, no se puede abrir otra puerta
    if (absorptionState !== "idle") {
      showMessage("Complete the absorption first", "warning");
      return;
    }

    // Verificar si esta puerta est치 desbloqueada en la secuencia
    if (!isDoorUnlocked(doorNumber)) {
      const nextDoor = getNextDoor();
      showMessage(
        `Door ${doorNumber} is locked. Find door ${nextDoor} first.`,
        "warning"
      );
      return;
    }

    // Abrir la puerta
    const opened = openDoorInSequence(doorNumber);
    if (opened) {
      setIsOpen(true);
      onDoorOpen(doorNumber); // Pasa el n칰mero de puerta directamente (1-9)

      // Disparar evento especial para puerta 9
      if (doorNumber === 9) {
        onNinthDoorOpened();
      }
    }
  };

  // Chequear si la puerta est치 desbloqueada para el prompt
  const isUnlocked = isDoorUnlocked(doorNumber);

  return (
    <group position={position} rotation={rotation}>
      <group
        userData={{
          interactable: true,
          type: "door",
          doorNumber,
          onInteract: toggleDoor,
          getActionPrompt: () => {
            if (!canInteractRef.current) return null;
            const currentlyOpen = isDoorCurrentlyOpen(doorNumberRef.current);

            // Si est치 abierta, no mostrar prompt (cierre es autom치tico)
            if (currentlyOpen) return null;

            // Si hay absorci칩n en progreso, no mostrar prompt
            if (absorptionState !== "idle") return null;

            // Si est치 cerrada, mostrar prompt solo si est치 desbloqueada
            const unlocked = isDoorUnlocked(doorNumberRef.current);
            return unlocked
              ? `Press E to open door ${doorNumberRef.current}`
              : null;
          },
        }}
      >
        {/* N칰mero de la puerta */}

        {/* Mesh visual de la puerta - se rota */}
        <group
          ref={doorMeshRef}
          position={[0.39, 1.117, -0.017]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        >
          <Text
            position={[-0.4, 0.6, 0.042745]}
            scale={[-1, 1, 1]}
            fontSize={0.25}
            color={isUnlocked && canInteract ? "#00ff00" : "#888888"}
            anchorX="center"
            anchorY="middle"
            outlineWidth={0.004}
            outlineColor="#000000"
          >
            {doorNumber}
          </Text>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004.geometry}
            material={materials["door wood"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004_1.geometry}
            material={materials["vray hr134.001"]}
          />
        </group>
        {/* Marco de la puerta - est치tico */}
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.frame.geometry}
          material={materials["door wood"]}
          position={[-0.195, 1.081, 0.009]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        />
        {/* Collider kinematic */}
        <RigidBody ref={doorRbRef} type="kinematicPosition" colliders="hull">
          <mesh
            geometry={nodes.Mesh004.geometry}
            rotation={[0, 0, Math.PI * 2]}
            scale={-1}
          >
            <meshBasicMaterial transparent opacity={0} />
          </mesh>
        </RigidBody>
      </group>
    </group>
  );
}

// Posiciones de todas las puertas del pasillo (modelo small)
const DOOR_POSITIONS: {
  position: [number, number, number];
  rotation?: [number, number, number];
}[] = [
  { position: [-7.995, 0, 1.026] }, // Door 1
  { position: [-5.463, 0, 1.026] }, // Door 2
  { position: [-2.783, 0, 1.026] }, // Door 3
  { position: [0, 0, 1.026] }, // Door 4
  { position: [-0.019, -0.01, -0.999], rotation: [Math.PI, 0, Math.PI] }, // Door 5
  { position: [-2.743, 0, -0.998], rotation: [Math.PI, 0, Math.PI] }, // Door 6
  { position: [-5.477, 0, -0.983], rotation: [Math.PI, 0, Math.PI] }, // Door 7
  { position: [-8.023, 0, -0.975], rotation: [Math.PI, 0, Math.PI] }, // Door 8
  { position: [-10.649, 0, -0.008], rotation: [Math.PI, -1.562, Math.PI] }, // Door 9
];

// Posiciones de los planos con im치genes detr치s de cada puerta
// Ratio 2:3 (ancho:alto), tama침o aproximado de puerta
const PLANE_WIDTH = 0.8 * 2;
const PLANE_HEIGHT = 1.2 * 2;
const PLANE_OFFSET_Z = 0.05; // Distancia detr치s de la puerta

const DOOR_IMAGE_PLANES: {
  doorNumber: number;
  position: [number, number, number];
  rotation: [number, number, number];
}[] = [
  // Puertas lado frontal (1-4) - miran hacia z negativo
  {
    doorNumber: 1,
    position: [-7.995, 1.1, 1.026 + PLANE_OFFSET_Z],
    rotation: [0, Math.PI, 0],
  },
  {
    doorNumber: 2,
    position: [-5.463, 1.1, 1.026 + PLANE_OFFSET_Z],
    rotation: [0, Math.PI, 0],
  },
  {
    doorNumber: 3,
    position: [-2.783, 1.1, 1.026 + PLANE_OFFSET_Z],
    rotation: [0, Math.PI, 0],
  },
  {
    doorNumber: 4,
    position: [0, 1.1, 1.026 + PLANE_OFFSET_Z],
    rotation: [0, Math.PI, 0],
  },
  // Puertas lado trasero (5-8) - miran hacia z positivo
  {
    doorNumber: 5,
    position: [-0.019, 1.1, -0.999 - PLANE_OFFSET_Z],
    rotation: [0, 0, 0],
  },
  {
    doorNumber: 6,
    position: [-2.743, 1.1, -0.998 - PLANE_OFFSET_Z],
    rotation: [0, 0, 0],
  },
  {
    doorNumber: 7,
    position: [-5.477, 1.1, -0.983 - PLANE_OFFSET_Z],
    rotation: [0, 0, 0],
  },
  {
    doorNumber: 8,
    position: [-8.023, 1.1, -0.975 - PLANE_OFFSET_Z],
    rotation: [0, 0, 0],
  },
  // Puerta 9 - extremo del pasillo
  {
    doorNumber: 9,
    position: [-10.649 - PLANE_OFFSET_Z, 1.1, -0.008],
    rotation: [0, -Math.PI / 2, 0],
  },
];

// Componente para el plano con imagen detr치s de cada puerta
interface DoorImagePlaneProps {
  doorNumber: number;
  position: [number, number, number];
  rotation: [number, number, number];
}

function DoorImagePlane({
  doorNumber,
  position,
  rotation,
}: DoorImagePlaneProps) {
  const doorConfig = getDoorByNumber(doorNumber);
  const isDoorOpen = useDoorSequence((state) =>
    state.openedDoors.has(doorNumber)
  );
  const collectOrb = useOrbStore((state) => state.collectOrb);
  const carriedOrb = useOrbStore((state) => state.carriedOrb);
  const isOrbDelivered = useOrbStore((state) => state.isOrbDelivered);
  const absorptionState = useOrbStore((state) => state.absorptionState);

  // No renderizar si no hay imagen (ej: puerta 9)
  if (!doorConfig?.image_url) return null;

  const texture = useTexture(doorConfig.image_url);

  // El orbe ya fue recolectado de esta puerta o ya fue entregado?
  const alreadyCollected =
    carriedOrb?.doorNumber === doorNumber || isOrbDelivered(doorNumber);

  const handleCollect = () => {
    if (!isDoorOpen) return;
    if (alreadyCollected) return;
    if (absorptionState !== "idle") return; // Hay absorci칩n en progreso
    if (carriedOrb !== null) {
      // Ya tiene un orbe, no puede recoger otro
      console.log("游댩 Already carrying an orb!");
      return;
    }
    collectOrb(doorNumber);
  };

  return (
    <group
      position={position}
      rotation={rotation}
      userData={{
        interactable: true,
        type: "door-image",
        doorNumber,
        getActionPrompt: () => {
          if (!isDoorOpen) return null;
          if (alreadyCollected) return null;
          if (absorptionState !== "idle") return null; // No mostrar si hay absorci칩n
          if (carriedOrb !== null) return "Deliver current orb first";
          return `Press E to collect orb (Door ${doorNumber})`;
        },
        onInteract: handleCollect,
      }}
    >
      <RigidBody type="fixed" colliders="trimesh">
        <mesh>
          <planeGeometry args={[PLANE_WIDTH, PLANE_HEIGHT]} />
          <MeshDistortMaterial
            distort={0.2}
            speed={1}
            map={texture}
            side={THREE.DoubleSide}
          />
        </mesh>
      </RigidBody>
    </group>
  );
}

const OniricHallway = forwardRef<
  OniricHallwayRef,
  React.JSX.IntrinsicElements["group"]
>(function OniricHallway(props, ref) {
  const { nodes, materials } = useGLTF(
    "/Oniric_Hallway_small.glb"
  ) as unknown as GLTFResult;

  // El ref ya no controla una puerta espec칤fica, pero lo mantenemos por compatibilidad
  useImperativeHandle(ref, () => ({
    openDoor: () => {},
    closeDoor: () => {},
    toggleDoor: () => {},
    isOpen: false,
  }));

  return (
    <group {...props} dispose={null}>
      <group name="Scene">
        {/* Todas las puertas como instancias del componente Door */}
        {DOOR_POSITIONS.map((door, index) => (
          <Door
            key={index}
            doorNumber={index + 1}
            position={door.position}
            rotation={door.rotation}
            nodes={nodes}
            materials={materials}
          />
        ))}

        {/* Planos con im치genes detr치s de cada puerta */}
        {DOOR_IMAGE_PLANES.map((plane) => (
          <DoorImagePlane
            key={plane.doorNumber}
            doorNumber={plane.doorNumber}
            position={plane.position}
            rotation={plane.rotation}
          />
        ))}

        {/* Estructura est치tica CON colliders */}
        <RigidBody type="fixed" colliders="trimesh">
          <mesh
            name="Plane"
            castShadow
            receiveShadow
            geometry={nodes.Plane.geometry}
            material={materials["Red Carpet"]}
            position={[-0.003, 0.034, 0.007]}
          />
          <mesh
            name="Paredes"
            castShadow
            receiveShadow
            geometry={nodes.Paredes.geometry}
            material={materials["Wooden wall"]}
            position={[-0.003, 0.002, 0.02]}
          />
          <mesh
            name="Collider"
            castShadow
            receiveShadow
            geometry={nodes.Collider.geometry}
            material={materials["Material.032"]}
            position={[-0.003, 0.913, 0.007]}
          />
        </RigidBody>
      </group>
    </group>
  );
});

export default OniricHallway;

useGLTF.preload("/Oniric_Hallway_small.glb");
