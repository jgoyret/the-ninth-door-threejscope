/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, {
  forwardRef,
  useImperativeHandle,
  useState,
  useRef,
} from "react";
import { useGLTF, Text } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import type { GLTF } from "three-stdlib";
import { RigidBody, type RapierRigidBody } from "@react-three/rapier";
import { useGame } from "../../game";
import { useGameUI } from "../../stores/useGameUI";
import { useDoorSequence } from "../../stores/useDoorSequence";
import { useCanvasManager } from "../../stores/useCanvasManager";

export interface OniricHallwayRef {
  openDoor: () => void;
  closeDoor: () => void;
  toggleDoor: () => void;
  isOpen: boolean;
}

type GLTFResult = GLTF & {
  nodes: {
    // Puerta (reutilizada para todas las instancias)
    Mesh004: THREE.Mesh;
    Mesh004_1: THREE.Mesh;
    frame: THREE.Mesh;
    // Estructura estática
    Pasillo: THREE.Mesh;
    Plane: THREE.Mesh;
    Paredes: THREE.Mesh;
  };
  materials: {
    ["door wood"]: THREE.MeshPhysicalMaterial;
    ["vray hr134.001"]: THREE.MeshPhysicalMaterial;
    Material: THREE.MeshStandardMaterial;
    ["Red Carpet"]: THREE.MeshStandardMaterial;
    ["Wooden wall"]: THREE.MeshStandardMaterial;
  };
};

// Componente Door reutilizable - cada instancia tiene su propio estado
interface DoorProps {
  doorNumber: number; // 1-9
  position: [number, number, number];
  rotation?: [number, number, number];
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}

function Door({
  doorNumber,
  position,
  rotation = [0, 0, 0],
  nodes,
  materials,
}: DoorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const doorMeshRef = useRef<THREE.Group>(null);
  const doorRbRef = useRef<RapierRigidBody>(null);
  const { onDoorOpen, canInteract } = useGame();
  const showMessage = useGameUI((state) => state.showMessage);

  // Sistema de secuencia de puertas
  const isDoorUnlocked = useDoorSequence((state) => state.isDoorUnlocked);
  const openDoorInSequence = useDoorSequence((state) => state.openDoor);
  const getNextDoor = useDoorSequence((state) => state.getNextDoor);

  // Canvas manager para eventos de cambio de canvas
  const onFirstDoorOpened = useCanvasManager((state) => state.onFirstDoorOpened);
  const onNinthDoorOpened = useCanvasManager((state) => state.onNinthDoorOpened);

  // Refs para acceso estable en callbacks
  const isOpenRef = useRef(isOpen);
  const canInteractRef = useRef(canInteract);
  const doorNumberRef = useRef(doorNumber);
  isOpenRef.current = isOpen;
  canInteractRef.current = canInteract;
  doorNumberRef.current = doorNumber;

  // Ángulo actual de la puerta (para animación suave)
  const currentAngle = useRef(0);
  const targetAngle = useRef(0);

  // Vectores temporales para sincronizar collider
  const tempPosition = useRef(new THREE.Vector3());
  const tempQuaternion = useRef(new THREE.Quaternion());

  // Animación y sincronización del collider
  useFrame((_, delta) => {
    const openAngle = -Math.PI / 1.1;
    targetAngle.current = isOpen ? openAngle : 0;
    currentAngle.current = THREE.MathUtils.lerp(
      currentAngle.current,
      targetAngle.current,
      delta
    );

    if (doorMeshRef.current) {
      doorMeshRef.current.rotation.y = currentAngle.current;

      if (doorRbRef.current) {
        doorMeshRef.current.getWorldPosition(tempPosition.current);
        doorMeshRef.current.getWorldQuaternion(tempQuaternion.current);
        doorRbRef.current.setNextKinematicTranslation(tempPosition.current);
        doorRbRef.current.setNextKinematicRotation(tempQuaternion.current);
      }
    }
  });

  const toggleDoor = () => {
    // Primero verificar si el stream está conectado
    if (!canInteract) {
      showMessage("The door is locked", "warning");
      return;
    }

    // Verificar si esta puerta está desbloqueada en la secuencia
    if (!isDoorUnlocked(doorNumber)) {
      const nextDoor = getNextDoor();
      showMessage(
        `Door ${doorNumber} is locked. Find door ${nextDoor} first.`,
        "warning"
      );
      return;
    }

    // Abrir la puerta
    const opened = openDoorInSequence(doorNumber);
    if (opened) {
      setIsOpen(true);
      onDoorOpen(doorNumber - 1); // onDoorOpen usa índice 0-based

      // Disparar eventos de cambio de canvas
      if (doorNumber === 1) {
        onFirstDoorOpened();
      }
      if (doorNumber === 9) {
        onNinthDoorOpened();
      }
    }
  };

  // Chequear si la puerta está desbloqueada para el prompt
  const isUnlocked = isDoorUnlocked(doorNumber);

  return (
    <group position={position} rotation={rotation}>
      <group
        userData={{
          interactable: true,
          type: "door",
          doorNumber,
          onInteract: toggleDoor,
          getActionPrompt: () => {
            if (isOpenRef.current) return null;
            if (!canInteractRef.current) return null;
            const unlocked = isDoorUnlocked(doorNumberRef.current);
            return unlocked
              ? `Open door ${doorNumberRef.current} with E`
              : null;
          },
        }}
      >
        {/* Número de la puerta */}

        {/* Mesh visual de la puerta - se rota */}
        <group
          ref={doorMeshRef}
          position={[0.39, 1.117, -0.017]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        >
          <Text
            position={[-0.4, 0.6, 0.042745]}
            scale={[-1, 1, 1]}
            fontSize={0.25}
            color={isUnlocked && canInteract ? "#00ff00" : "#888888"}
            anchorX="center"
            anchorY="middle"
            outlineWidth={0.004}
            outlineColor="#000000"
          >
            {doorNumber}
          </Text>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004.geometry}
            material={materials["door wood"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004_1.geometry}
            material={materials["vray hr134.001"]}
          />
        </group>
        {/* Marco de la puerta - estático */}
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.frame.geometry}
          material={materials["door wood"]}
          position={[-0.195, 1.081, 0.009]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        />
        {/* Collider kinematic */}
        <RigidBody ref={doorRbRef} type="kinematicPosition" colliders="hull">
          <mesh
            geometry={nodes.Mesh004.geometry}
            rotation={[0, 0, Math.PI * 2]}
            scale={-1}
          >
            <meshBasicMaterial transparent opacity={0} />
          </mesh>
        </RigidBody>
      </group>
    </group>
  );
}

// Posiciones de todas las puertas del pasillo
const DOOR_POSITIONS: {
  position: [number, number, number];
  rotation?: [number, number, number];
}[] = [
  { position: [0, 0, 1.026] },
  { position: [-5.969, 0, 1.026] },
  { position: [-12.054, 0, 1.026] },
  { position: [-17.946, 0, 1.026] },
  { position: [-20.017, 0, -0.008], rotation: [Math.PI, -1.562, Math.PI] },
  { position: [-0.019, -0.01, -0.999], rotation: [Math.PI, 0, Math.PI] },
  { position: [-5.969, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
  { position: [-12.08, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
  { position: [-17.985, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
];

const OniricHallway = forwardRef<
  OniricHallwayRef,
  React.JSX.IntrinsicElements["group"]
>(function OniricHallway(props, ref) {
  const { nodes, materials } = useGLTF(
    "/Oniric_Hallway.glb"
  ) as unknown as GLTFResult;

  // El ref ya no controla una puerta específica, pero lo mantenemos por compatibilidad
  useImperativeHandle(ref, () => ({
    openDoor: () => {},
    closeDoor: () => {},
    toggleDoor: () => {},
    isOpen: false,
  }));

  return (
    <group {...props} dispose={null}>
      <group name="Scene">
        {/* Todas las puertas como instancias del componente Door */}
        {DOOR_POSITIONS.map((door, index) => (
          <Door
            key={index}
            doorNumber={index + 1}
            position={door.position}
            rotation={door.rotation}
            nodes={nodes}
            materials={materials}
          />
        ))}

        {/* Estructura estática CON colliders */}
        <RigidBody type="fixed" colliders="trimesh">
          <mesh
            name="Pasillo"
            castShadow
            receiveShadow
            geometry={nodes.Pasillo.geometry}
            material={materials.Material}
            position={[-0.003, 0.002, 0.02]}
          />
          <mesh
            name="Plane"
            castShadow
            receiveShadow
            geometry={nodes.Plane.geometry}
            material={materials["Red Carpet"]}
            position={[-0.003, 0.034, 0.007]}
          />
          <mesh
            name="Paredes"
            castShadow
            receiveShadow
            geometry={nodes.Paredes.geometry}
            material={materials["Wooden wall"]}
            position={[-0.003, 0.002, 0.02]}
          />
        </RigidBody>
      </group>
    </group>
  );
});

export default OniricHallway;

useGLTF.preload("/Oniric_Hallway.glb");
