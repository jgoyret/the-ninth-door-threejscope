/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, {
  forwardRef,
  useImperativeHandle,
  useState,
  useRef,
} from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import type { GLTF } from "three-stdlib";
import { RigidBody, type RapierRigidBody } from "@react-three/rapier";
import { useGame } from "../../game";

export interface OniricHallwayRef {
  openDoor: () => void;
  closeDoor: () => void;
  toggleDoor: () => void;
  isOpen: boolean;
}

type GLTFResult = GLTF & {
  nodes: {
    // Puerta (reutilizada para todas las instancias)
    Mesh004: THREE.Mesh;
    Mesh004_1: THREE.Mesh;
    frame: THREE.Mesh;
    // Estructura estática
    Pasillo: THREE.Mesh;
    Plane: THREE.Mesh;
    Paredes: THREE.Mesh;
  };
  materials: {
    ["door wood"]: THREE.MeshPhysicalMaterial;
    ["vray hr134.001"]: THREE.MeshPhysicalMaterial;
    Material: THREE.MeshStandardMaterial;
    ["Red Carpet"]: THREE.MeshStandardMaterial;
    ["Wooden wall"]: THREE.MeshStandardMaterial;
  };
};

// Componente Door reutilizable - cada instancia tiene su propio estado
interface DoorProps {
  index: number;
  position: [number, number, number];
  rotation?: [number, number, number];
  nodes: GLTFResult["nodes"];
  materials: GLTFResult["materials"];
}

function Door({ index, position, rotation = [0, 0, 0], nodes, materials }: DoorProps) {
  const [isOpen, setIsOpen] = useState(false);
  const doorMeshRef = useRef<THREE.Group>(null);
  const doorRbRef = useRef<RapierRigidBody>(null);
  const { onDoorOpen, canInteract } = useGame();

  // Ángulo actual de la puerta (para animación suave)
  const currentAngle = useRef(0);
  const targetAngle = useRef(0);

  // Vectores temporales para sincronizar collider
  const tempPosition = useRef(new THREE.Vector3());
  const tempQuaternion = useRef(new THREE.Quaternion());

  // Animación y sincronización del collider
  useFrame((_, delta) => {
    // Lerp del ángulo de la puerta
    const openAngle = -Math.PI / 1.1; // 90 grados
    targetAngle.current = isOpen ? openAngle : 0;
    currentAngle.current = THREE.MathUtils.lerp(
      currentAngle.current,
      targetAngle.current,
      delta // velocidad de la animación
    );

    // Aplicar rotación al mesh visual
    if (doorMeshRef.current) {
      doorMeshRef.current.rotation.y = currentAngle.current;

      // Sincronizar collider con la posición del mesh
      if (doorRbRef.current) {
        doorMeshRef.current.getWorldPosition(tempPosition.current);
        doorMeshRef.current.getWorldQuaternion(tempQuaternion.current);
        doorRbRef.current.setNextKinematicTranslation(tempPosition.current);
        doorRbRef.current.setNextKinematicRotation(tempQuaternion.current);
      }
    }
  });

  const toggleDoor = () => {
    // Solo permitir interacción si el stream está conectado
    if (!canInteract) return;

    setIsOpen((prev) => {
      const newState = !prev;
      // Cuando se abre, enviar el prompt
      if (newState) {
        onDoorOpen(index);
      }
      return newState;
    });
  };

  return (
    <group position={position} rotation={rotation}>
      <group
        userData={{ interactable: true, type: "door", onInteract: toggleDoor }}
      >
        {/* Mesh visual de la puerta - se rota */}
        <group
          ref={doorMeshRef}
          position={[0.39, 1.117, -0.017]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004.geometry}
            material={materials["door wood"]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Mesh004_1.geometry}
            material={materials["vray hr134.001"]}
          />
        </group>
        {/* Marco de la puerta - estático */}
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.frame.geometry}
          material={materials["door wood"]}
          position={[-0.195, 1.081, 0.009]}
          rotation={[0, 0, Math.PI]}
          scale={-1}
        />
        {/* Collider kinematic */}
        <RigidBody ref={doorRbRef} type="kinematicPosition" colliders="hull">
          <mesh
            geometry={nodes.Mesh004.geometry}
            rotation={[0, 0, Math.PI * 2]}
            scale={-1}
          >
            <meshBasicMaterial transparent opacity={0} />
          </mesh>
        </RigidBody>
      </group>
    </group>
  );
}

// Posiciones de todas las puertas del pasillo
const DOOR_POSITIONS: {
  position: [number, number, number];
  rotation?: [number, number, number];
}[] = [
  { position: [0, 0, 1.026] },
  { position: [-5.969, 0, 1.026] },
  { position: [-12.054, 0, 1.026] },
  { position: [-17.946, 0, 1.026] },
  { position: [-20.017, 0, -0.008], rotation: [Math.PI, -1.562, Math.PI] },
  { position: [-0.019, -0.01, -0.999], rotation: [Math.PI, 0, Math.PI] },
  { position: [-5.969, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
  { position: [-12.08, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
  { position: [-17.985, 0, -0.998], rotation: [Math.PI, 0, Math.PI] },
];

const OniricHallway = forwardRef<
  OniricHallwayRef,
  React.JSX.IntrinsicElements["group"]
>(function OniricHallway(props, ref) {
  const { nodes, materials } = useGLTF(
    "/Oniric_Hallway.glb"
  ) as unknown as GLTFResult;

  // El ref ya no controla una puerta específica, pero lo mantenemos por compatibilidad
  useImperativeHandle(ref, () => ({
    openDoor: () => {},
    closeDoor: () => {},
    toggleDoor: () => {},
    isOpen: false,
  }));

  return (
    <group {...props} dispose={null}>
      <group name="Scene">
        {/* Todas las puertas como instancias del componente Door */}
        {DOOR_POSITIONS.map((door, index) => (
          <Door
            key={index}
            index={index}
            position={door.position}
            rotation={door.rotation}
            nodes={nodes}
            materials={materials}
          />
        ))}

        {/* Estructura estática CON colliders */}
        <RigidBody type="fixed" colliders="trimesh">
          <mesh
            name="Pasillo"
            castShadow
            receiveShadow
            geometry={nodes.Pasillo.geometry}
            material={materials.Material}
            position={[-0.003, 0.002, 0.02]}
          />
          <mesh
            name="Plane"
            castShadow
            receiveShadow
            geometry={nodes.Plane.geometry}
            material={materials["Red Carpet"]}
            position={[-0.003, 0.034, 0.007]}
          />
          <mesh
            name="Paredes"
            castShadow
            receiveShadow
            geometry={nodes.Paredes.geometry}
            material={materials["Wooden wall"]}
            position={[-0.003, 0.002, 0.02]}
          />
        </RigidBody>
      </group>
    </group>
  );
});

export default OniricHallway;

useGLTF.preload("/Oniric_Hallway.glb");
